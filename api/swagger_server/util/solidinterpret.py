import re


def openContract(name, access):
    return open('swagger_server/contracts/%s' % name, access)


def readContract(name):
    fp = openContract(name, 'r')
    data = fp.read()
    fp.close()
    return data


class CustomContract():
    Itembase = {"name": "ItemBase", "code": readContract(
        "itembase.sol"), "filename": "itembase.sol"}
    ERC20 = {"name": "FixedSupplyToken", "code": readContract(
        "erc20.sol"), "filename": "erc20.sol"}


# translates common types (float, double) into solidity types
# takes strings and returns strings
def translateType(t):
    if (t == "double"):
        return "uint64"
    elif (t == "float"):
        return "uint32"
    else:
        return t


# returns solidity code for events written with the CTRL JSON Spec
def eventsCode(events):
    eventLines = []

    # decipher events dictionary 1 key at a time
    for k in events.keys():
        args = events[k]

        # dummies
        argStr = ""
        t = None
        indices = 0
        argNames = ""

        # iterate through this event's args
        for a in args.keys():
            argNames += (a + ", ")
            indexed = "indexed "  # LEAVE WEIRD SPACE IN; NEEDED FOR FORMATTING
            print(k)
            print(a)
            t = translateType(args[a])
            args[a] = t
            if (indices < 3):  # only 3 args can be indexed; the first 3
                indices += 1
            else:
                indexed = ""

            # build solidity args string
            argStr += "%s %s%s, " % (args[a], indexed, a)

        # strip trailing comma & space from arg strings
        argStr = argStr[:-2]
        argNames = argNames[:-2]

        # add line of event code to output
        event = "event %s(%s);" % (k, argStr)
        eventLines.append(event)

        function = '''
        function do_%s(%s) public {
            emit %s(%s);
        }
        ''' % (k, argStr.replace("indexed ", ""), k, argNames)

        eventLines.append(function)

    return eventLines


# contract: CustomContract
# extraCode: string
def integrateCode(contract, extraCode=None, options=None):
    ogCode = readContract(contract['filename'])

    # pattern that finds the contract to modify
    pattern = 'contract %s[^{]*\{' % contract['name']

    openBracket = re.search(pattern, ogCode).end()
    prefix = ogCode[:openBracket]
    suffix = ogCode[openBracket:]
    comment = "// Auto-generated by LedgerCTRL API " + '-'*43

    codeStr = ""
    if (extraCode):
        for line in extraCode:
            codeStr += "    %s\n" % line

    output = "%s\n%s\n%s%s\n%s" % (
        prefix, comment, codeStr, '// ' + '-'*76, suffix)

    return output
